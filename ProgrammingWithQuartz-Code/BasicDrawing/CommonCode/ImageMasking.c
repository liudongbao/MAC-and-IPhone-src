/*
*  File:    ImageMasking.c
*  
*  Copyright:  Copyright © 2005 Apple Computer, Inc., All Rights Reserved
* 
*  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. ("Apple") in 
*        consideration of your agreement to the following terms, and your use, installation, modification 
*        or redistribution of this Apple software constitutes acceptance of these terms.  If you do 
*        not agree with these terms, please do not use, install, modify or redistribute this Apple 
*        software.
*
*        In consideration of your agreement to abide by the following terms, and subject to these terms, 
*        Apple grants you a personal, non-exclusive license, under Apple's copyrights in this 
*        original Apple software (the "Apple Software"), to use, reproduce, modify and redistribute the 
*        Apple Software, with or without modifications, in source and/or binary forms; provided that if you 
*        redistribute the Apple Software in its entirety and without modifications, you must retain this 
*        notice and the following text and disclaimers in all such redistributions of the Apple Software. 
*        Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to 
*        endorse or promote products derived from the Apple Software without specific prior written 
*        permission from Apple.  Except as expressly stated in this notice, no other rights or 
*        licenses, express or implied, are granted by Apple herein, including but not limited to any 
*        patent rights that may be infringed by your derivative works or by other works in which the 
*        Apple Software may be incorporated.
*
*        The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR 
*        IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY 
*        AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
*        OR IN COMBINATION WITH YOUR PRODUCTS.
*
*        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
*        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
*        OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, 
*        REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
*        UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN 
*        IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/

#include "Utilities.h"
#include "ImageMasking.h"
#include "Images.h"
#include "DataProvidersAndConsumers.h"

void exportImageWithMaskFromURLWithDestination(CGContextRef context,
				    CFURLRef imageURL, size_t imagewidth,
				    size_t imageheight, size_t bitsPerComponent, 
				    CFURLRef theMaskingImageURL, size_t maskwidth,
				    size_t maskheight)
{
	CGImageRef image = NULL, mask = NULL, imageMaskedWithImage = NULL;
	CGRect imageRect, maskRect;
	size_t imageBitsPerPixel = bitsPerComponent * 3;
	size_t bytesPerRow = ( (imagewidth * imageBitsPerPixel) + 7)/8;
	bool shouldInterpolate = true;
	CGColorSpaceRef colorspace = NULL;
	CGDataProviderRef maskDataProvider = NULL;
	CGDataProviderRef imageDataProvider = CGDataProviderCreateWithURL(imageURL);
	if(imageDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}
	colorspace = getTheCalibratedRGBColorSpace();
	image = CGImageCreate(imagewidth, imageheight, bitsPerComponent,
							imageBitsPerPixel, bytesPerRow, colorspace,
							kCGImageAlphaNone, imageDataProvider, 
							NULL, shouldInterpolate,
							kCGRenderingIntentDefault);
	CGDataProviderRelease(imageDataProvider);
	if(image == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for this data!\n");
		return;
	}
	imageRect = CGRectMake(0.,imageheight, imagewidth, imageheight);
	// Draw the image.
	CGContextDrawImage(context, imageRect, image);
	
	// Now the mask.
	maskDataProvider = CGDataProviderCreateWithURL(theMaskingImageURL);
	if(maskDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}
	
	mask = CGImageMaskCreate(maskwidth, maskheight, bitsPerComponent,
							bitsPerComponent, maskwidth,
							maskDataProvider, NULL, shouldInterpolate);
	CGDataProviderRelease(maskDataProvider);
	if(mask == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for mask data!\n");
		return;
	}
	
	// Draw the mask below the image.
	maskRect = CGRectMake(0., 0., maskwidth, maskheight);
	CGContextDrawImage(context, maskRect, mask);
	
	// Create a new CGImage object, the image, masked with mask.
	imageMaskedWithImage = CGImageCreateWithMask(image, mask);
	// Once the new image is created, we can release the image
	// and the mask which make it up. Quartz retains what it needs
	// for the new masked image.
	CGImageRelease(image);
	CGImageRelease(mask);
	if(imageMaskedWithImage == NULL){
		fprintf(stderr, "Couldn't create image masked with mask!\n");
		return;
	}
	imageRect = CGRectMake(imagewidth, imageheight/2, 
							imagewidth, imageheight);
	// Draw the masked image to the right of the image and its mask.
	CGContextDrawImage(context, imageRect, imageMaskedWithImage);

	// Of course this is a total hack.
	char *outPath = "/tmp/imageout.png";
	CFURLRef exportURL = CFURLCreateFromFileSystemRepresentation(NULL,
				    outPath, strlen(outPath), false);
		
	if(exportURL){
	    exportCGImageToPNGFileWithDestination(imageMaskedWithImage, 
						    exportURL);
	    CFRelease(exportURL);
	}

	// Be sure and release the masked image.
	CGImageRelease(imageMaskedWithImage);	
}

static const unsigned char *getMaskData1()
{
    static const unsigned char data[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFE, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x03, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xF8, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x40, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0,
	0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF,
	0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF8,
	0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF8, 0x00, 0x00, 0x7F, 0xFF,
	0xFF, 0xFE, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFC, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
	0x00, 0x7F, 0xFF, 0xFC, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFC,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
	0xFF, 0xF0, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
	0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF,
	0xFF, 0xE0, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0x80, 0x01, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00,
	0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF,
	0x80, 0x00, 0x1F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF,
	0xFF, 0xF8, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x1F, 0xFF, 0xFF, 0xF8, 0x00, 0x00,
	0x7F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x1F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFE,
	0x40, 0x00, 0x0F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF,
	0xFF, 0xFC, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFC, 0x00, 0x01,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFC, 0x00, 0x05, 0xEF, 0xFF, 0xFE, 0x00,
	0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xF0, 0x00, 0x3F, 0x00, 0x03, 0xFC, 0x00, 0x00, 0x00, 0x3F, 0xFF,
	0xFF, 0xE0, 0x00, 0x7C, 0x00, 0x00, 0x78, 0x1F, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xC0, 0x00, 0x38,
	0x00, 0x00, 0x78, 0x3C, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x78, 0x00, 0x00, 0x70, 0x18,
	0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x78, 0x1F, 0x00, 0x30, 0x00, 0x00, 0x01, 0xFF, 0xFF,
	0xFF, 0xFE, 0x00, 0x7C, 0x3F, 0x00, 0x18, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x80, 0x00, 0x3C, 0x00,
	0x0C, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x20, 0x1C, 0x03, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x04, 0x00, 0x3C, 0x00, 0x3C, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x70,
	0xBF, 0x86, 0x3C, 0x1F, 0xFC, 0x0B, 0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x11, 0xF0, 0x0E, 0x3C, 0x1F,
	0xFE, 0x8B, 0xFF, 0xFF, 0xFF, 0xFF, 0xA0, 0x19, 0xF0, 0x0C, 0x3C, 0x0F, 0xFF, 0x0B, 0xFF, 0xFF,
	0xFF, 0xFF, 0xB0, 0x1D, 0xFE, 0x1C, 0x7E, 0x0F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xB8, 0x1C,
	0xFF, 0x3C, 0xFE, 0x03, 0xFE, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1E, 0x7F, 0xF8, 0xDE, 0x00,
	0x7C, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1E, 0x7F, 0xF1, 0xDF, 0x30, 0x03, 0x83, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x1F, 0x3F, 0xE3, 0x9F, 0x10, 0x3F, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x0F,
	0xFF, 0x83, 0xDF, 0x80, 0x1F, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x03, 0xFC, 0x03, 0xDF, 0x81,
	0x8F, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x07, 0xFE, 0x1F, 0x8F, 0x00, 0x07, 0x83, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x07, 0xFE, 0x3C, 0x06, 0x00, 0x01, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
	0xFC, 0x7C, 0x00, 0x00, 0x01, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xF8, 0x7F, 0x00, 0x00,
	0x01, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xF8, 0xFF, 0xE0, 0x30, 0x01, 0x83, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0xF1, 0xEF, 0xF9, 0xE0, 0x03, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,
	0xF1, 0xFF, 0xFF, 0x80, 0x0F, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x03, 0xE2, 0xFF, 0xFE, 0x00,
	0x1F, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xF0, 0x00, 0x00, 0x1C, 0x3F, 0x87, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xC3, 0xF0, 0x00, 0x01, 0xF8, 0x0F, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3,
	0xF0, 0x03, 0xFF, 0xF0, 0x5F, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xC7, 0xFF, 0xE0,
	0x7F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xF1, 0xFF, 0x80, 0x2F, 0x0F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xF8, 0x0F, 0xC0, 0x06, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4,
	0xFF, 0xFE, 0x0F, 0xF8, 0x44, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xFF, 0xFF, 0xFF, 0xF8,
	0x64, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0x3C, 0xE4, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFD, 0x9F, 0xFF, 0xFC, 0x1F, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD,
	0x1F, 0xFF, 0xFC, 0x03, 0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x01, 0xFF, 0xFF, 0xFF,
	0xC0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x7F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
	0x80, 0x7F, 0xFF, 0xFF, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x80, 0x1F, 0xFF, 0xFF,
	0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xC0, 0x0F, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07, 0xFF, 0xFF, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xF0, 0x03, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x70, 0x01, 0xFF, 0xFC,
	0x00, 0x17, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x78, 0x00, 0x7F, 0xF0, 0x00, 0x07, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF0, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
	0xFE, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1F, 0xFF, 0x80, 0x00, 0x00,
	0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7F, 0x7F, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF
    };
    return data;
}

static const unsigned char *getMaskData2()
{
    static const unsigned char data[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x1F, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 
	0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xE0, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 
	0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x01, 
	0x80, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x07, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x0B, 0xE0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 
	0x00, 0x00, 0x00, 0x07, 0xF0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x1F, 
	0xF4, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x3F, 0xE4, 0x03, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x3F, 0xE4, 0x43, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 
	0x00, 0x00, 0x00, 0x3F, 0xE4, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x02, 0xFF,
	0xE4, 0x5B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x02, 0xFF, 0xE0, 0x5B, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x07, 0xC1, 0xFF, 0xE0, 0x59, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x18,
	0x00, 0x7F, 0xF0, 0xFE, 0x00, 0x79, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x18, 0x00, 0x78, 0x0F, 0xFE, 
	0x04, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x18, 0x00, 0xB0, 0x47, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFE, 0x10, 0x00, 0xC4, 0x69, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x10, 
	0x01, 0xFF, 0xE1, 0xFC, 0x07, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x01, 0xFF, 0xF8, 0x78,
	0x01, 0xC5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x04, 0x01, 0xFF, 0xF0, 0x78, 0x01, 0xC5, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFC, 0x0C, 0x00, 0xFF, 0xF8, 0x7E, 0x3F, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x0C,
	0x00, 0x7F, 0xF0, 0x18, 0xFF, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x07, 0x00, 0x7F, 0xF4, 0x1F, 
	0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x23, 0x00, 0x7F, 0xE0, 0x3E, 0xFF, 0xE3, 0xFF, 0xFF,
	0xFF, 0xFF, 0xF8, 0x11, 0x00, 0x7F, 0xEC, 0x5F, 0xBF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 
	0x00, 0x3F, 0xCE, 0x7E, 0x3F, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x08, 0x00, 0x7F, 0x80, 0x2E,
	0x3F, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x06, 0x00, 0x7F, 0x00, 0x6E, 0x3F, 0xEB, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x7E, 0x0D, 0xFE, 0xFF, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
	0x00, 0x3C, 0x00, 0xFE, 0x3F, 0xEB, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x50, 0x00, 0xFE, 
	0x3F, 0xCB, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x01, 0x98, 0xFF, 0x3F, 0xCB, 0xFF, 0xFF,
	0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xC7, 0xE1, 0xFF, 0x3F, 0x8B, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 
	0x00, 0x40, 0xFF, 0xFF, 0xBF, 0x8B, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xE0, 0x1F, 0xFF,
	0xDF, 0x0B, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0xE8, 0x63, 0xFF, 0xDF, 0x0F, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xF0, 0x00, 0x02, 0xFC, 0xF9, 0xFF, 0xEF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00,
	0x03, 0xFE, 0x7F, 0xF8, 0x1E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x03, 0x7E, 0x0F, 0xF9, 
	0xBE, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x01, 0x7F, 0xC1, 0xF3, 0xFC, 0x05, 0xFF, 0xFF,
	0xFF, 0xFF, 0xE0, 0x00, 0x01, 0x3D, 0xF8, 0x0F, 0x7C, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 
	0x01, 0xBC, 0x7F, 0xFF, 0xF8, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0xBE, 0xFF, 0xFF,
	0xF8, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x1D, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x0F, 0xF7, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
	0x00, 0x0F, 0xF3, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x03, 0xF3, 0xFF, 
	0xC0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x01, 0xF7, 0xFF, 0x80, 0x00, 0x3F, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 
	0x00, 0x00, 0x1F, 0xFF, 0x00, 0x20, 0x3F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF,
	0x00, 0x10, 0x3F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x10, 0x3F, 0xFF, 
	0xFF, 0xFC, 0x00, 0x00, 0x02, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFC, 0x00, 0x00,
	0x04, 0x00, 0x1F, 0xFE, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x07, 0x81, 0x7F, 0xFE, 
	0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x03, 0xDF, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF,
	0xFF, 0xF8, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 
	0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xF0, 0x00, 0x40, 0x07, 0xFF, 0xFF, 0xFE,
	0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0xC0, 0x03, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x0F, 0xFF, 
	0xFF, 0xE0, 0x00, 0xE0, 0x07, 0xFF, 0xFF, 0xFE, 0x81, 0x00, 0x07, 0xFF, 0xFF, 0xC0, 0x01, 0xE0,
	0x07, 0xFF, 0xFF, 0xFE, 0x01, 0x00, 0x07, 0xFF, 0xFF, 0x80, 0x0F, 0xF0, 0x03, 0xFF, 0xFF, 0xFE, 
	0x83, 0x80, 0x03, 0xFF, 0xFF, 0x00, 0x1F, 0xF0, 0x13, 0xFF, 0xFF, 0xFE, 0x03, 0xE0, 0x01, 0xFF,
	0xFC, 0x03, 0x3F, 0xF0, 0x21, 0xFF, 0xFF, 0xFE, 0x03, 0xFC, 0x00, 0x3F, 0xF0, 0x3F, 0x3F, 0xF8, 
	0x3B, 0xFF, 0xFF, 0xFE, 0x03, 0xFE, 0xC0, 0x0F, 0xE3, 0xFB, 0x7F, 0xF8, 0x3B, 0xFF, 0xFF, 0xFF, 
	0x07, 0xFF, 0xFF, 0x07, 0x9F, 0xFB, 0x7F, 0xFC, 0x79, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0x7F, 0xFC, 0x39, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE,
	0x3F, 0xFF, 0xFF, 0xFE, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE, 0x1F, 0xFF, 0xFF, 0xFE, 
	0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE, 0x1F, 0x7F, 0xFF, 0xFE, 0x0F, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0x7F, 0xFF, 0x1F, 0xFE, 0xFF, 0xFC, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0x0F, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFE, 
	0x1F, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0x82, 0xFF, 0xFF, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xBF, 0xFF, 0x83, 0xFF, 0xFF, 0xFC, 0x3F, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xC1, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xE0, 0xFF, 0xFF, 0xF0, 
	0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    };
    return data;
}


void doOneBitMaskImages(CGContextRef context)
{
	static const size_t bitsPerComponent = 1, bitsPerPixel = 1;
	static const size_t width = 96, height = 96;
	static const size_t bytesPerRow = 12;
	CGImageRef mask1, invertedmask1, mask2, invertedmask2;
	CGRect imageRect, backRect;
	size_t imageDataSize = bytesPerRow*height;
	Boolean shouldInterpolate = true;
	static const float lightBlue[] = { 0.482, 0.62, 0.871, 1. };	
	static const float black[] = { 0., 0., 0., 1. };
	static const float darkRed[] = { 0.663, 0., 0.031, 1. };
	static const float darkGreen[] = { 0.404, 0.808, 0.239, 1. };
	static const float darkBlue[] = { 0.11, 0.208, 0.451, 1. };
	float purple[] = { 0.69, 0.486, 0.722, 1. };
	float darkOrange[] = { 0.965, 0.584, 0.059, 1. };
	CGColorSpaceRef colorSpace = NULL;
	/*
	    A decode array contains two elements for each component. In this
	    case, an image mask has one component so the array consists of
	    two values. When using this decode array, a sample value of 0
	    is mapped into the value 1, and the maximum sample value is
		mapped into the value 0. This inverts the sense of the mask data.
	*/
	float decode[2] = {1 , 0};
	
	// Create a Quartz data provider for the image data. Because this 
	// data is static data, we don't need to release it so the data 
	// release function is NULL.
	unsigned const char *data = getMaskData1();
	CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, data, imageDataSize, NULL);
	if(dataProvider == NULL){
		fprintf(stderr, "Couldn't create Mask1 Data provider!\n");
		return;
	}
	
	// Create a mask from the data.
	mask1 = CGImageMaskCreate(width, height, bitsPerComponent,
					bitsPerPixel, bytesPerRow, dataProvider, 
					NULL, shouldInterpolate);
	// Create the same mask but with a decode array that 
	// inverts the sense of the mask.
	invertedmask1 = CGImageMaskCreate(width, height, 
					bitsPerComponent, bitsPerPixel, bytesPerRow, 
					dataProvider, decode, shouldInterpolate);
	// Release the data provider now that this code no longer needs it.
	CGDataProviderRelease(dataProvider);
	if(mask1 == NULL || invertedmask1 == NULL){
	    if(mask1 == NULL)
			fprintf(stderr, "Couldn't create CGImageRef for the mask data 1!\n");
	    else
			CGImageRelease(mask1);
	    
	    if(invertedmask1 == NULL)
			fprintf(stderr, "Couldn't create CGImageRef for the inverted mask data 1!\n");
	    else
			CGImageRelease(invertedmask1);

	    return;
	}

	// Get the pointer to the data for the second mask.
	data = getMaskData2();
	dataProvider = CGDataProviderCreateWithData(NULL, data, imageDataSize, NULL);
	if(dataProvider == NULL){
		CGImageRelease(mask1);
		CGImageRelease(invertedmask1);		
		fprintf(stderr, "Couldn't create Mask2 Data provider!\n");
		return;
	}
	
	mask2 = CGImageMaskCreate(width, height, bitsPerComponent,
					bitsPerPixel, bytesPerRow, dataProvider, 
					NULL, shouldInterpolate);
	// Create the same mask but with a decode array that 
	// inverts the sense of the mask.
	invertedmask2 = CGImageMaskCreate(width, height, 
					bitsPerComponent, bitsPerPixel, bytesPerRow, 
					dataProvider, decode, shouldInterpolate);
	// Release the data provider now that this code no longer needs it.
	CGDataProviderRelease(dataProvider);
	if(mask2 == NULL || invertedmask2 == NULL){
	    if(mask2 == NULL)
			fprintf(stderr, "Couldn't create CGImageRef for the mask data 2!\n");
	    else
			CGImageRelease(mask2);
	    
	    if(invertedmask2 == NULL)
			fprintf(stderr, "Couldn't create CGImageRef for the inverted mask data 2!\n");
	    else
			CGImageRelease(invertedmask2);

	    CGImageRelease(mask1);
	    CGImageRelease(invertedmask1);		
	    return;
	}
	
	CGContextScaleCTM(context, 1.5, 1.5);
	colorSpace = getTheCalibratedRGBColorSpace();
	CGContextSetFillColorSpace(context, colorSpace);	
	
	// Set the fill color to a light blue.
	CGContextSetFillColor(context, lightBlue);
	// Paint part of the background.
	backRect = CGRectMake(width/2, height/2, width*3, height);
	CGContextFillRect(context, backRect);
	
	imageRect = CGRectMake(0., height, width, height);
	CGContextSaveGState(context);
	    // Set the fill color to opaque black.
	    CGContextSetFillColor(context, black);
	    // Mask 1.
	    CGContextDrawImage(context, imageRect, mask1);
	    
	    CGContextTranslateCTM(context, width, 0);
	    // Set the fill color to opaque red.
	    CGContextSetFillColor(context, darkRed);			
	    // Mask 2.
	    CGContextDrawImage(context, imageRect, mask2);
	    CGContextTranslateCTM(context, width, 0);
	    // Set the fill color to dark orange.
	    CGContextSetFillColor(context, darkOrange);
	    // Mask 3.
	    CGContextDrawImage(context, imageRect, mask1);

	    CGContextTranslateCTM(context, width, 0);
	    // Make the orange 50% transparent.
	    darkOrange[3] = 0.5;
	    CGContextSetFillColor(context, darkOrange);
	    // Mask 4.
	    CGContextDrawImage(context, imageRect, mask2);
	CGContextRestoreGState(context);
	
	// Translate down the page. The cast is necessary
	// since height is typed as size_t which is unsigned.
	CGContextTranslateCTM(context, 0, -(signed)height);
	
	// Set the fill color to an opaque green.
	CGContextSetFillColor(context, darkGreen);
	// Mask 5.
	CGContextDrawImage(context, imageRect, invertedmask2);
	
	CGContextTranslateCTM(context, width, 0);
	// Set the fill color to a dark blue.
	CGContextSetFillColor(context, darkBlue);
	// Mask 6.
	CGContextDrawImage(context, imageRect, invertedmask1);
	CGContextTranslateCTM(context, width, 0);
	// Set the fill color to purple.
	CGContextSetFillColor(context, purple);
	// Mask 7.
	CGContextDrawImage(context, imageRect, invertedmask2);
	CGContextTranslateCTM(context, width, 0);
	
	// Make the purple 50% transparent.
	purple[3] = 0.5;
	CGContextSetFillColor(context, purple);
	// Mask 8.
	CGContextDrawImage(context, imageRect, invertedmask1);
	// Release the CGImageRefs when they are no longer needed.
	CGImageRelease(mask1);
	CGImageRelease(invertedmask1);
	CGImageRelease(mask2);
	CGImageRelease(invertedmask2);
}

void doMaskImageWithMaskFromURL(CGContextRef context, CFURLRef imageURL, size_t imagewidth,
				    size_t imageheight, size_t bitsPerComponent, 
				    CFURLRef theMaskingImageURL, size_t maskwidth,
				    size_t maskheight)
{
	CGImageRef image = NULL, mask = NULL, imageMaskedWithImage = NULL;
	CGRect imageRect, maskRect;
	size_t imageBitsPerPixel = bitsPerComponent * 3;
	size_t bytesPerRow = ( (imagewidth * imageBitsPerPixel) + 7)/8;
	Boolean shouldInterpolate = true;
	CGColorSpaceRef colorspace = NULL;
	CGDataProviderRef maskDataProvider = NULL;
	CGDataProviderRef imageDataProvider = 
							CGDataProviderCreateWithURL(imageURL);
	if(imageDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}
	colorspace = getTheCalibratedRGBColorSpace();
	image = CGImageCreate(imagewidth, imageheight, bitsPerComponent,
							imageBitsPerPixel, bytesPerRow, colorspace,
							kCGImageAlphaNone, imageDataProvider, 
							NULL, shouldInterpolate,
							kCGRenderingIntentDefault);
	CGDataProviderRelease(imageDataProvider);
	if(image == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for this data!\n");
		return;
	}
	imageRect = CGRectMake(0.,imageheight, imagewidth, imageheight);
	// Draw the image.
	CGContextDrawImage(context, imageRect, image);
	
	// Now the mask.
	maskDataProvider = CGDataProviderCreateWithURL(theMaskingImageURL);
	if(maskDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}
	
	mask = CGImageMaskCreate(maskwidth, maskheight, bitsPerComponent,
							bitsPerComponent, maskwidth,
							maskDataProvider, NULL, shouldInterpolate);
	CGDataProviderRelease(maskDataProvider);
	if(mask == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for mask data!\n");
		return;
	}
	
	// Draw the mask below the image. The current fill color (black)
	// is painted through the mask.
	maskRect = CGRectMake(0., 0., maskwidth, maskheight);
	CGContextDrawImage(context, maskRect, mask);
	
	// Create a new CGImage object, the image, masked with mask.
	imageMaskedWithImage = CGImageCreateWithMask(image, mask);
	// Once the new image is created, the code can release the image
	// and the mask which make it up. Quartz retains what it needs
	// for the new masked image 'imageMaskedWithImage'.
	CGImageRelease(image);
	CGImageRelease(mask);
	if(imageMaskedWithImage == NULL){
		fprintf(stderr, "Couldn't create image masked with mask!\n");
		return;
	}
	imageRect = CGRectMake(imagewidth + 10, imageheight/2, 
							imagewidth, imageheight);
	// Draw the masked image to the right of the image and its mask.
	CGContextDrawImage(context, imageRect, imageMaskedWithImage);
	// Be sure and release the masked image.
	CGImageRelease(imageMaskedWithImage);	
}

void doMaskImageWithGrayImageFromURL(CGContextRef context, CFURLRef imageURL, size_t imagewidth,
				    size_t imageheight, size_t bitsPerComponent, 
				    CFURLRef theMaskingImageURL, size_t maskwidth,
				    size_t maskheight)
{
	CGImageRef image = NULL, mask = NULL, imageMaskedWithImage = NULL;
	CGRect imageRect, maskRect;
	size_t imageBitsPerPixel = bitsPerComponent * 3;
	size_t bytesPerRow = ( (imagewidth * imageBitsPerPixel) + 7)/8;
	Boolean shouldInterpolate = true;
	CGColorSpaceRef colorspace, deviceGraySpace;
	CGDataProviderRef maskDataProvider = NULL;
	CGDataProviderRef imageDataProvider = CGDataProviderCreateWithURL(imageURL);
	if(imageDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}
	colorspace = getTheCalibratedRGBColorSpace();
	image = CGImageCreate(imagewidth, imageheight, bitsPerComponent,
							imageBitsPerPixel, bytesPerRow, colorspace,
							kCGImageAlphaNone, imageDataProvider, 
							NULL, shouldInterpolate,
							kCGRenderingIntentDefault);
	CGDataProviderRelease(imageDataProvider);
	if(image == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for this data!\n");
		return;
	}
	imageRect = CGRectMake(0.,imageheight, imagewidth, imageheight);
	// Draw the image.
	CGContextDrawImage(context, imageRect, image);
	
	// Now the mask.
	maskDataProvider = CGDataProviderCreateWithURL(theMaskingImageURL);
	if(maskDataProvider == NULL){
		fprintf(stderr, "Couldn't create Image Data provider!\n");
		return;
	}

	// The color space for the image MUST be DeviceGray for it to   
	// be used as a masking image with CGImageCreateWithMask.
	deviceGraySpace = CGColorSpaceCreateDeviceGray();   
	mask = CGImageCreate(maskwidth, maskheight, bitsPerComponent, 
					bitsPerComponent, maskwidth, 
					deviceGraySpace, 
					kCGImageAlphaNone, maskDataProvider, 
					NULL, shouldInterpolate, 
					kCGRenderingIntentDefault);
	// Release the color space since it is no longer needed.
	CGColorSpaceRelease(deviceGraySpace);
	CGDataProviderRelease(maskDataProvider);

	if(mask == NULL){
		fprintf(stderr, "Couldn't create CGImageRef for gray image data!\n");
		return;
	}
	
	// Draw the mask below the image. The current fill color (black)
	// is painted through the mask.
	maskRect = CGRectMake(0., 0., maskwidth, maskheight);
	CGContextDrawImage(context, maskRect, mask);
	
	// Create a new CGImage object, the image, masked with mask.
	imageMaskedWithImage = CGImageCreateWithMask(image, mask);
	
	// Once the new image is created, the code can release the image
	// and the mask which make it up. Quartz retains what it needs
	// for the new masked image 'imageMaskedWithImage'.
	CGImageRelease(image);
	CGImageRelease(mask);
	if(imageMaskedWithImage == NULL){
		fprintf(stderr, "Couldn't create image masked with mask!\n");
		return;
	}
	imageRect = CGRectMake(imagewidth + 10, imageheight/2, 
							imagewidth, imageheight);
	// Draw the masked image to the right of the image and its mask.
	CGContextDrawImage(context, imageRect, imageMaskedWithImage);
	// Be sure and release the masked image.
	CGImageRelease(imageMaskedWithImage);	
}

void doMaskImageWithColorFromURL(CGContextRef context, CFURLRef url,
 					size_t width, size_t height,
					Boolean isColor)
{
	CGImageRef image = NULL, imageMaskedWithColor = NULL;
	// This routine treats color images as RGB.
	size_t bitsPerComponent = 8;
	size_t bitsPerPixel = isColor ? (bitsPerComponent * 3) : bitsPerComponent;
	size_t bytesPerRow = ( (width * bitsPerPixel) + 7)/8;
	Boolean shouldInterpolate = true;
	CGRect imageRect;
	// This is a range of dark gray to black colors for an 8 bit per component
	// image in a gray or RGB color space. The entries are image sample 
	// values of 0-0x1F for the first color component, 0-0x1F for the 
	// second color component, and so on. For image sample values where 
	// all components fall within the ranges in maskingColors, the sample 
	// value is masked and therefore unpainted.
	float maskingColors[6] = { 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F };
	float backColor[] = {1., 0., 0., 1.}; // Opaque red.
	CGColorSpaceRef colorspace = NULL;
	// Create a Quartz data provider from the supplied URL.	 
	CGDataProviderRef dataProvider = CGDataProviderCreateWithURL(url);
	if(dataProvider == NULL){
		fprintf(stderr, "Couldn't create Image data provider!\n");
		return;
	}
	// Create an image of the specified width, height and bits per pixel
	// from the URL.
	colorspace =  isColor ? getTheCalibratedRGBColorSpace() : getTheCalibratedGrayColorSpace();
	image = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel,
					bytesPerRow, colorspace, kCGImageAlphaNone,
					dataProvider, NULL, shouldInterpolate, 
					kCGRenderingIntentDefault);
	CGDataProviderRelease(dataProvider);
	if(image == NULL){
	    fprintf(stderr, "Couldn't create CGImageRef for this data!\n");
	    return;
	}
	imageRect = CGRectMake(10., 10., width, height);
	//CGContextScaleCTM(context, 0.33, 0.33);
	// Set the color space and the color, then 
	// paint a red rectangle behind the image.
	CGContextSetFillColorSpace(context, colorspace);
	CGContextSetFillColor(context, backColor);
	CGContextFillRect(context, imageRect);
	// Draw the image into the rectangle.
	CGContextDrawImage(context, imageRect, image);
	// Create a new image from the original one, masking out a range
	// of the blackest sample values.
	imageMaskedWithColor = CGImageCreateWithMaskingColors(image,
								 maskingColors);
	// Release the original image; it is no longer needed.
	CGImageRelease(image);
	if(imageMaskedWithColor == NULL){
	    fprintf(stderr, "Couldn't create CGImageRef for masking color!\n");
	    return;
	}
	
	// Paint the rectangle behind the next image with red.
	imageRect = CGRectMake(30. + width, 10., width, height);
	CGContextFillRect(context, imageRect);
	// Draw the image. Image sample values in the range of
	// the masking color are unpainted, allowing the background
	// to show through.
	CGContextDrawImage(context, imageRect, imageMaskedWithColor);
	
	// Release the image masked with color.
	CGImageRelease(imageMaskedWithColor);
}

#if 1		// Set to 1 for code in the book.
void drawWithClippingMask(CGContextRef context, 
				CFURLRef theMaskingImageURL, 
				size_t imagewidth, size_t imageheight)
{
    // An array of CGColor objects.
    CGColorRef colors[4] = { getRGBOpaqueDarkGreenColor(), 
		getRGBOpaqueDarkBlueColor(),  getRGBOpaqueBlueColor(), 
		getRGBOpaqueRedColor() };
    size_t imageBitsPerComponent = 8;
    size_t bytesPerRow = imagewidth;
    Boolean shouldInterpolate = true;
    CGImageRef image;
    CGDataProviderRef dataProvider;
    CGRect imageRect, rect;
    float decode[] = { 1, 0 };
    int i,j;
    CGColorSpaceRef cs;
    
    // Create the data.
    dataProvider =  CGDataProviderCreateWithURL(theMaskingImageURL);
    if(dataProvider == NULL){
	    fprintf(stderr, "Couldn't create Image data provider!\n");
	    return;
    }
    cs = CGColorSpaceCreateDeviceGray();
    image = CGImageCreate(imagewidth, imageheight, 
			    imageBitsPerComponent, imageBitsPerComponent, 
			    bytesPerRow, cs, kCGImageAlphaNone, dataProvider, decode, 
			    shouldInterpolate, kCGRenderingIntentDefault);
    CGColorSpaceRelease(cs);
    CGDataProviderRelease(dataProvider);

    if(image == NULL){
	    fprintf(stderr, "Couldn't create Image!\n");
	    return;
    }
    imageRect = CGRectMake(0, 0, imagewidth*2/3, imageheight*2/3);

    // Position for drawing the image at the left side of the figure.
    CGContextTranslateCTM(context, 50, 50 );

    // Draw the image.
    CGContextDrawImage(context, imageRect, image);

    // Position to the right of the image just painted.
    CGContextTranslateCTM(context, CGRectGetWidth(imageRect) + 25,  0);

    // Clip to the image.
    CGContextClipToMask(context, imageRect, image);
    // Release the image since this code no longer needs it.
    CGImageRelease(image);

    // Make a rect that has a width and height 1/3 that of the image.
    rect = CGRectMake(0, 0, CGRectGetWidth(imageRect)/3, CGRectGetHeight(imageRect)/3);

    CGContextTranslateCTM(context, 0, 2*CGRectGetHeight(rect));
    
    // Draw a 3 x 3 grid of rectangles, setting the color for each rectangle
    // by cycling through the array of CGColor objects in the 'colors' array.
    for(j = 0 ; j < 3 ; j++){
		CGContextSaveGState(context);
			for(i = 0 ; i < 3 ; i++){
				// Draw a row of rectangles.
				// Set the fill color using one of the CGColor objects in the 
				// colors array.	    
				CGContextSetFillColorWithColor(context, colors[(i+j) % 4]);
				CGContextFillRect(context, rect);
				CGContextTranslateCTM(context, CGRectGetWidth(rect), 0);
			}
		CGContextRestoreGState(context);
		// Position to draw the next row.
		CGContextTranslateCTM(context, 0, -CGRectGetHeight(rect));
    }
}
#else
// This code works just fine to screen but when drawing to a PDF 
// or printing context the masked drawing is completely masked out 
// due to a bug in Quartz prior to Tiger 10.4.3.
void drawWithClippingMask(CGContextRef context, 
				CFURLRef theMaskingImageURL, 
				size_t maskwidth, size_t maskheight)
{
    // An array of CGColor objects.
    CGColorRef colors[4] = { getRGBOpaqueDarkGreenColor(), 
		getRGBOpaqueDarkBlueColor(),  getRGBOpaqueBlueColor(), 
		getRGBOpaqueRedColor() };
    size_t maskBitsPerComponent = 8;
    size_t bytesPerRow = ( (maskwidth * maskBitsPerComponent) + 7)/8;
    Boolean shouldInterpolate = true;
    CGImageRef mask;
    CGDataProviderRef maskDataProvider = CGDataProviderCreateWithURL(theMaskingImageURL);
    CGRect maskRect, rect;
    int i,j;
    
    if(maskDataProvider == NULL){
	    fprintf(stderr, "Couldn't create Image Mask provider!\n");
	    return;
    }
    mask = CGImageMaskCreate(maskwidth, maskheight, maskBitsPerComponent,
				    maskBitsPerComponent, maskwidth,
				    maskDataProvider, NULL, shouldInterpolate);
    CGDataProviderRelease(maskDataProvider);

    if(mask == NULL){
	    fprintf(stderr, "Couldn't create Image Mask!\n");
	    return;
    }
    maskRect = CGRectMake(0, 0, maskwidth/3, maskheight/3);

    // Position for drawing the mask at the left side of the figure.
    CGContextTranslateCTM(context, 50, 50 );
    // Set the context fill color to a CGColor object that is black.
    CGContextSetFillColorWithColor(context, getRGBOpaqueBlackColor());
    // Draw the mask. It is painted with with the black fill color.
    CGContextDrawImage(context, maskRect, mask);

    // Position to the right of the mask just painted.
    CGContextTranslateCTM(context, CGRectGetWidth(maskRect) + 25,  0);

    // Clip to the mask.
    CGContextClipToMask(context, maskRect, mask);
    // Release the mask since this code no longer needs it.
    CGImageRelease(mask);

    // Make a rect that has a width and height 1/3 that of the image mask.
    rect = CGRectMake(0, 0, CGRectGetWidth(maskRect)/3, CGRectGetHeight(maskRect)/3);

    CGContextTranslateCTM(context, 0, 2*CGRectGetHeight(rect));
    
    // Draw a 3 x 3 grid of rectangles, setting the color for each rectangle
    // by cycling through the array of CGColor objects in the 'colors' array.
    for(j = 0 ; j < 3 ; j++){
		CGContextSaveGState(context);
			for(i = 0 ; i < 3 ; i++){
				// Draw a row of rectangles.
				// Set the fill color using one of the CGColor objects in the 
				// colors array.	    
				CGContextSetFillColorWithColor(context, colors[(i+j) % 4]);
				CGContextFillRect(context, rect);
				CGContextTranslateCTM(context, CGRectGetWidth(rect), 0);
			}
		CGContextRestoreGState(context);
		// Position to draw the next row.
		CGContextTranslateCTM(context, 0, -CGRectGetHeight(rect));
    }
}
#endif
